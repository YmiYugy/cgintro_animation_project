#version 430 core
#extension GL_ARB_compute_shader: enable
#extension GL_ARB_shader_storage_buffer_object: enable

layout(
local_size_x = 64,
local_size_y = 1,
local_size_z = 1
) in;

struct Boid
{
    vec4 pos;
    vec4 vel;
};

struct Evasion {
    bool will_collide;
    float dist;
};

layout(std430, binding = 0) buffer Boids
{
    Boid boids[];
};

layout(std430, binding = 1) buffer Indices
{
    uint indices[];
};

layout(std430, binding = 2) buffer Vertices
{
    vec4 verticies[];
};

layout(std430, binding = 3) buffer SamplePoints {
    vec4 samplePoints[];
};

layout(std430, binding = 4) buffer Boids2
{
    Boid boids2[];
};


uniform uint triangle_count;
uniform uint boid_count;
uniform uint sample_count;
uniform float delta;

#define eps 0.005

const float max_steer_force = 3;
const float max_speed = 3;
const float min_speed = 0.5;
const float view_radius = 1.5;
const float avoid_radius = 0.2;
const float align_weight = 3;
const float cohesion_weight = 6;
const float seperate_weight = 10.5;
const float collisions_avoid_dst = 2.5;
const float avoid_collision_weight = 100;

Evasion needs_evasion(vec3 v0, vec3 v1, vec3 v2, vec3 start, vec3 end) {

    vec3 u = v1 - v0;
    vec3 v = v2 - v0;
    vec3 n = cross(u, v);
    float n_n = length(n);
    if (n_n == 0) {
        return Evasion(false, 0);
    }
    n = normalize(n);

    vec3 dir = end - start;// direction of line segment
    float a = dot(n, v0-start);
    float b = dot(n, dir);

    if (b == 0) { // triangle parallel to segment
        if (a == 0) {
            return Evasion(false, 0);// in the same plane better avoid
        } else {
            return Evasion(false, 0);// disjoint no need to act
        }
    }

    float r = a / b;
    if (r < 0.0 || r > 1.0) { // intersection of line with plane outside segment
        return Evasion(false, r*length(dir));
    }

    vec3 i = start + r * dir;// intersection point
    vec3 w = i-v0;

    float m1 = dot(u, w)/dot(u, u);
    float m2 = dot(v, w)/dot(v, v);
    if (m1 < 0 || m1 > 1 || m2 < 0 || m2 > 1) {
        return Evasion(false, 0);
    } else {
        return Evasion(true, r*length(dir));
    }
}

vec3 orthogonal(vec3 v) {
    float x = abs(v.x);
    float y = abs(v.y);
    float z = abs(v.z);

    vec3 other = x < y ? (x < z ? vec3(1, 0, 0) : vec3(0, 0, 1)) : (y < z ? vec3(0, 1, 0) : vec3(0, 0, 1));
    return cross(v, other);
}

vec4 get_rotation_between(vec3 u, vec3 v) {
    vec4 q;
    vec3 v0 = normalize(u);
    vec3 v1 = normalize(v);

    float d = dot(v0, v1);

    if (d < (eps - 1.0)) {
        q = vec4(normalize(orthogonal(u)), 0);
    } else {
        float s = sqrt((1+d)*2);
        float invs = 1/s;

        vec3 c = cross(v0, v1);

        q.x = c.x * invs;
        q.y = c.y * invs;
        q.z = c.z * invs;
        q.w = s * 0.5;
        q = normalize(q);
    }
    return q;
}

vec3 rotate(vec4 quaternion, vec3 vec) {
    return vec + 2.0 * cross(quaternion.xyz, cross(quaternion.xyz, vec) + quaternion.w * vec);
}

vec3 steer_towards(vec3 vec, vec3 vel) {
    float l = length(vec);
    if (abs(l) < eps) {
        return vec3(0);
    }
    vec3 v = vec/l * max_speed - vel;
    l = length(v);
    if (abs(l) < eps) {
        return vec3(0);
    }
    return clamp(l, 0, max_steer_force) * v/l;
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    vec3 pos = boids[gid].pos.xyz;
    vec3 vel = boids[gid].vel.xyz;



    vec3 acceleration = vec3(0);

    {
        vec3 center = vec3(0);
        vec3 alignment = vec3(0);
        uint mates = 0;
        vec3 separate = vec3(0);

        for (uint i = 0; i < boid_count; i++) {
            if (i == gid) continue;

            Boid boid = boids[i];
            vec3 offset = boid.pos.xyz - pos;
            float dist2 = dot(offset, offset);
            if (dist2 < view_radius * view_radius) {
                center += boids[i].pos.xyz;
                alignment += boid.vel.xyz;
                mates++;
            }
            if (dist2 < avoid_radius * avoid_radius) {
                separate -= (boid.pos.xyz-pos)/dist2;
            }
        }

        if (mates > 0) {
            center /= mates;
            center -= pos;
        }

        acceleration += steer_towards(center, vel) * cohesion_weight;
        acceleration += steer_towards(alignment, vel) * align_weight;
        acceleration += steer_towards(separate, vel) * seperate_weight;
    }

    vec4 q_rot = get_rotation_between(vec3(1, 0, 0), vel);

    float distance = 0;
    uint failed_samples = 0;
    for (uint j = 0; j < sample_count; j++) {
        bool evade = false;
        float local_distance = 1/0;
        vec3 start = pos;
        vec3 end = pos + collisions_avoid_dst * normalize(rotate(q_rot, samplePoints[j].xyz));
        for (uint i = 0; i < triangle_count; i++) {
            vec3 v0 = verticies[indices[3*i + 0]].xyz;
            vec3 v1 = verticies[indices[3*i + 1]].xyz;
            vec3 v2 = verticies[indices[3*i + 2]].xyz;
            Evasion test = needs_evasion(v0, v1, v2, start, end);
            if (test.will_collide){
                evade = true;
                local_distance = min(test.dist, local_distance);
            }
        }
        distance += local_distance;
        failed_samples++;
        if (!evade){
            distance /= failed_samples;
            acceleration += steer_towards((end - pos) * 1/collisions_avoid_dst, vel) * 1/(distance * distance) * avoid_collision_weight;
            break;
        }
    }


    vel += acceleration*delta;
    {
        float speed = length(vel);
        vel = clamp(speed, min_speed, max_speed)*normalize(vel);
    }
    pos += vel * delta;

    boids2[gid].pos.xyz = pos;
    boids2[gid].vel.xyz = vel;


}
